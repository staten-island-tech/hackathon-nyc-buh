<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Charged Ammo Game with NYC Background and Enemy Fire</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #health-bar {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 200px;
      height: 20px;
      background: #600;
      border: 2px solid #a00;
      border-radius: 5px;
    }
    #health-fill {
      height: 100%;
      background: #0f0;
      width: 100%;
      border-radius: 3px;
      transition: width 0.2s ease;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
</head>
<body>

<div id="health-bar"><div id="health-fill"></div></div>

<script>
  let scene, camera, renderer;
  let player, floor;
  let keys = {}, enemies = [], projectiles = [], enemyProjectiles = [];
  const clock = new THREE.Clock();
  let cameraAngle = 0; // radians
  let playerHp = 10;
  const maxPlayerHp = 10;

  const enemyTextureUrl = "{{ url_for('static', filename='enemy.png') }}";

  init();
  animate();

  function init() {
    scene = new THREE.Scene();
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(100, 100);
    const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x222222 });
    floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Player
    const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
    const playerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.set(0, 0.5, 0);
    scene.add(player);

    // Add NYC buildings far in background
    createNYCBackgroundBuildings();

    // Controls
    document.addEventListener("keydown", (e) => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", (e) => keys[e.key.toLowerCase()] = false);
    window.addEventListener("resize", onWindowResize);
    document.addEventListener("mouseup", onShoot);

    setInterval(() => {
      if (enemies.length < 10) spawnEnemy();
    }, 1500);

    setInterval(enemyFire, 1500);

    updateHealthBar();
  }

  function createNYCBackgroundBuildings() {
  const buildingColors = [0x888888, 0xaaaaaa, 0x666666, 0x444444, 0x999999];
  const glassMaterial = new THREE.MeshPhongMaterial({
    color: 0x5588cc,
    transparent: true,
    opacity: 0.7,
    shininess: 100,
    specular: 0xddddff,
  });

  const blockSize = 5;
  const citySize = 80; // play area approx from -40 to 40 on X and Z
  const spacing = 10;

  const minHeight = 1;
  const maxHeight = 6;

  const edgeOffset = 15; // how far buildings sit from gameplay area edges

  // Place buildings along edges of a square ring around baseplate:
  for (let i = -citySize/2 - edgeOffset; i <= citySize/2 + edgeOffset; i += spacing) {
    // Front edge (Z = +outer)
    let height = minHeight + Math.random() * maxHeight;
    let material = Math.random() < 0.3 ? glassMaterial.clone() : new THREE.MeshLambertMaterial({color: buildingColors[Math.floor(Math.random() * buildingColors.length)]});
    let building = new THREE.Mesh(new THREE.BoxGeometry(blockSize, height, blockSize), material);
    building.position.set(i, height / 2, citySize/2 + edgeOffset);
    scene.add(building);

    // Back edge (Z = -outer)
    height = minHeight + Math.random() * maxHeight;
    material = Math.random() < 0.3 ? glassMaterial.clone() : new THREE.MeshLambertMaterial({color: buildingColors[Math.floor(Math.random() * buildingColors.length)]});
    building = new THREE.Mesh(new THREE.BoxGeometry(blockSize, height, blockSize), material);
    building.position.set(i, height / 2, -citySize/2 - edgeOffset);
    scene.add(building);

    // Left edge (X = -outer)
    height = minHeight + Math.random() * maxHeight;
    material = Math.random() < 0.3 ? glassMaterial.clone() : new THREE.MeshLambertMaterial({color: buildingColors[Math.floor(Math.random() * buildingColors.length)]});
    building = new THREE.Mesh(new THREE.BoxGeometry(blockSize, height, blockSize), material);
    building.position.set(-citySize/2 - edgeOffset, height / 2, i);
    scene.add(building);

    // Right edge (X = +outer)
    height = minHeight + Math.random() * maxHeight;
    material = Math.random() < 0.3 ? glassMaterial.clone() : new THREE.MeshLambertMaterial({color: buildingColors[Math.floor(Math.random() * buildingColors.length)]});
    building = new THREE.Mesh(new THREE.BoxGeometry(blockSize, height, blockSize), material);
    building.position.set(citySize/2 + edgeOffset, height / 2, i);
    scene.add(building);
  }
}


  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function spawnEnemy() {
    const loader = new THREE.TextureLoader();
    loader.load(enemyTextureUrl, (texture) => {
      const material = new THREE.SpriteMaterial({ map: texture });
      const enemy = new THREE.Sprite(material);
      enemy.scale.set(1, 1, 1);
      enemy.position.set(
        player.position.x + (Math.random() - 0.5) * 40,
        0.5,
        player.position.z + (Math.random() - 0.5) * 40
      );
      enemy.hp = 3;
      enemy.maxHp = 3;
      enemies.push(enemy);
      scene.add(enemy);
    });
  }

  function updatePlayerMovement() {
    const speed = 0.1;

    // Rotate camera with arrow keys
    if (keys["arrowleft"]) cameraAngle += 0.03;
    if (keys["arrowright"]) cameraAngle -= 0.03;

    // Movement relative to camera/player direction
    let forward = new THREE.Vector3(Math.sin(cameraAngle), 0, Math.cos(cameraAngle));
    let right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));

    if (keys["w"]) player.position.addScaledVector(forward, speed);
    if (keys["s"]) player.position.addScaledVector(forward, -speed);
    if (keys["a"]) player.position.addScaledVector(right, -speed);
    if (keys["d"]) player.position.addScaledVector(right, speed);

    // Update camera to follow player from behind
    const camDist = 10;
    camera.position.set(
      player.position.x - Math.sin(cameraAngle) * camDist,
      player.position.y + 5,
      player.position.z - Math.cos(cameraAngle) * camDist
    );
    camera.lookAt(player.position);
  }

  function onShoot(event) {
    const mouse = new THREE.Vector2(
      (event.clientX / window.innerWidth) * 2 - 1,
      -(event.clientY / window.innerHeight) * 2 + 1
    );

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(floor);
    if (intersects.length === 0) return;

    const target = intersects[0].point;
    launchAmmoArc(player.position.clone(), target);
  }

  function launchAmmoArc(start, end) {
    const ammoGeometry = new THREE.SphereGeometry(0.2, 16, 16);
    const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
    scene.add(ammo);

    const control = start.clone().lerp(end, 0.5);
    control.y += 5;

    const projectile = {
      mesh: ammo,
      start,
      control,
      end,
      t: 0,
      duration: 0.8 + Math.random() * 0.2,
      damage: 2,
      fromEnemy: false,
    };

    projectiles.push(projectile);
  }

  // Enemies shoot projectiles toward player
  function enemyFire() {
    enemies.forEach(enemy => {
      if (!enemy) return;

      const ammoGeometry = new THREE.SphereGeometry(0.15, 12, 12);
      const ammoMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      const ammo = new THREE.Mesh(ammoGeometry, ammoMaterial);
      scene.add(ammo);

      const start = enemy.position.clone();
      const end = player.position.clone();

      const control = start.clone().lerp(end, 0.5);
      control.y += 3;

      const projectile = {
        mesh: ammo,
        start,
        control,
        end,
        t: 0,
        duration: 1.0,
        damage: 1,
        fromEnemy: true,
      };

      enemyProjectiles.push(projectile);
    });
  }

  function updateProjectiles(delta) {
    for (let i = projectiles.length - 1; i >= 0; i--) {
      const p = projectiles[i];
      p.t += delta / p.duration;
      if (p.t >= 1) {
        explodeAt(p.end, p.damage);
        scene.remove(p.mesh);
        projectiles.splice(i, 1);
        continue;
      }

      const a = p.start.clone().lerp(p.control, p.t);
      const b = p.control.clone().lerp(p.end, p.t);
      const pos = a.lerp(b, p.t);
      p.mesh.position.copy(pos);
    }

    for (let i = enemyProjectiles.length - 1; i >= 0; i--) {
      const p = enemyProjectiles[i];
      p.t += delta / p.duration;
      if (p.t >= 1) {
        // Check if hit player (close enough)
        const dist = p.end.distanceTo(player.position);
        if (dist < 1.5) {
          damagePlayer(p.damage);
        }
        scene.remove(p.mesh);
        enemyProjectiles.splice(i, 1);
        continue;
      }

      const a = p.start.clone().lerp(p.control, p.t);
      const b = p.control.clone().lerp(p.end, p.t);
      const pos = a.lerp(b, p.t);
      p.mesh.position.copy(pos);
    }
  }

  function explodeAt(position, damage) {
    const radius = 3;

    // Damage enemies if projectile is player's ammo
    if (damage > 1) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        if (!enemy) continue;
        const dist = enemy.position.distanceTo(position);
        if (dist <= radius) {
          enemy.hp -= damage;
          if (enemy.hp <= 0) {
            scene.remove(enemy);
            enemies.splice(i, 1);
          }
        }
      }
    }

    // Visual explosion effect
    const boomGeometry = new THREE.SphereGeometry(radius, 16, 16);
    const boomMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.5 });
    const explosion = new THREE.Mesh(boomGeometry, boomMaterial);
    explosion.position.copy(position);
    scene.add(explosion);
    setTimeout(() => scene.remove(explosion), 300);
  }

  function damagePlayer(amount) {
    playerHp -= amount;
    if (playerHp < 0) playerHp = 0;
    updateHealthBar();
    if (playerHp <= 0) {
      alert("You died! Reload to try again.");
      // Optionally reset or disable controls here
      keys = {};
    }
  }

  function updateHealthBar() {
    const fill = document.getElementById("health-fill");
    fill.style.width = (playerHp / maxPlayerHp * 100) + "%";
  }

  function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    updatePlayerMovement();
    updateProjectiles(delta);
    renderer.render(scene, camera);
  }
</script>
</body>
</html>
